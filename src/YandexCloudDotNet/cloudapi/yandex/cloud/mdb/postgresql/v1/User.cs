// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: yandex/cloud/mdb/postgresql/v1/user.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Yandex.Cloud.Mdb.Postgresql.V1 {

  /// <summary>Holder for reflection information generated from yandex/cloud/mdb/postgresql/v1/user.proto</summary>
  internal static partial class UserReflection {

    #region Descriptor
    /// <summary>File descriptor for yandex/cloud/mdb/postgresql/v1/user.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UserReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cil5YW5kZXgvY2xvdWQvbWRiL3Bvc3RncmVzcWwvdjEvdXNlci5wcm90bxIe",
            "eWFuZGV4LmNsb3VkLm1kYi5wb3N0Z3Jlc3FsLnYxGh5nb29nbGUvcHJvdG9i",
            "dWYvd3JhcHBlcnMucHJvdG8aHXlhbmRleC9jbG91ZC92YWxpZGF0aW9uLnBy",
            "b3RvIpMCCgRVc2VyEgwKBG5hbWUYASABKAkSEgoKY2x1c3Rlcl9pZBgCIAEo",
            "CRI/CgtwZXJtaXNzaW9ucxgDIAMoCzIqLnlhbmRleC5jbG91ZC5tZGIucG9z",
            "dGdyZXNxbC52MS5QZXJtaXNzaW9uEhIKCmNvbm5fbGltaXQYBCABKAMSPgoI",
            "c2V0dGluZ3MYBSABKAsyLC55YW5kZXguY2xvdWQubWRiLnBvc3RncmVzcWwu",
            "djEuVXNlclNldHRpbmdzEikKBWxvZ2luGAYgASgLMhouZ29vZ2xlLnByb3Rv",
            "YnVmLkJvb2xWYWx1ZRIpCgZncmFudHMYByADKAlCGYrIMQQ8PTYz8scxDVth",
            "LXpBLVowLTlfXSoiIwoKUGVybWlzc2lvbhIVCg1kYXRhYmFzZV9uYW1lGAEg",
            "ASgJIuoCCghVc2VyU3BlYxIrCgRuYW1lGAEgASgJQh3oxzEBisgxBDw9NjPy",
            "xzENW2EtekEtWjAtOV9dKhIfCghwYXNzd29yZBgCIAEoCUIN6McxAYrIMQU4",
            "LTEyOBI/CgtwZXJtaXNzaW9ucxgDIAMoCzIqLnlhbmRleC5jbG91ZC5tZGIu",
            "cG9zdGdyZXNxbC52MS5QZXJtaXNzaW9uEjkKCmNvbm5fbGltaXQYBCABKAsy",
            "Gy5nb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZUII+scxBD49MTASPgoIc2V0",
            "dGluZ3MYBSABKAsyLC55YW5kZXguY2xvdWQubWRiLnBvc3RncmVzcWwudjEu",
            "VXNlclNldHRpbmdzEikKBWxvZ2luGAYgASgLMhouZ29vZ2xlLnByb3RvYnVm",
            "LkJvb2xWYWx1ZRIpCgZncmFudHMYByADKAlCGYrIMQQ8PTYz8scxDVthLXpB",
            "LVowLTlfXSoinwgKDFVzZXJTZXR0aW5ncxJoCh1kZWZhdWx0X3RyYW5zYWN0",
            "aW9uX2lzb2xhdGlvbhgBIAEoDjJBLnlhbmRleC5jbG91ZC5tZGIucG9zdGdy",
            "ZXNxbC52MS5Vc2VyU2V0dGluZ3MuVHJhbnNhY3Rpb25Jc29sYXRpb24SMQoM",
            "bG9ja190aW1lb3V0GAIgASgLMhsuZ29vZ2xlLnByb3RvYnVmLkludDY0VmFs",
            "dWUSPwoabG9nX21pbl9kdXJhdGlvbl9zdGF0ZW1lbnQYAyABKAsyGy5nb29n",
            "bGUucHJvdG9idWYuSW50NjRWYWx1ZRJaChJzeW5jaHJvbm91c19jb21taXQY",
            "BCABKA4yPi55YW5kZXguY2xvdWQubWRiLnBvc3RncmVzcWwudjEuVXNlclNl",
            "dHRpbmdzLlN5bmNocm9ub3VzQ29tbWl0EjQKD3RlbXBfZmlsZV9saW1pdBgF",
            "IAEoCzIbLmdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlElAKDWxvZ19zdGF0",
            "ZW1lbnQYBiABKA4yOS55YW5kZXguY2xvdWQubWRiLnBvc3RncmVzcWwudjEu",
            "VXNlclNldHRpbmdzLkxvZ1N0YXRlbWVudCLWAQoRU3luY2hyb25vdXNDb21t",
            "aXQSIgoeU1lOQ0hST05PVVNfQ09NTUlUX1VOU1BFQ0lGSUVEEAASGQoVU1lO",
            "Q0hST05PVVNfQ09NTUlUX09OEAESGgoWU1lOQ0hST05PVVNfQ09NTUlUX09G",
            "RhACEhwKGFNZTkNIUk9OT1VTX0NPTU1JVF9MT0NBTBADEiMKH1NZTkNIUk9O",
            "T1VTX0NPTU1JVF9SRU1PVEVfV1JJVEUQBBIjCh9TWU5DSFJPTk9VU19DT01N",
            "SVRfUkVNT1RFX0FQUExZEAUiigEKDExvZ1N0YXRlbWVudBIdChlMT0dfU1RB",
            "VEVNRU5UX1VOU1BFQ0lGSUVEEAASFgoSTE9HX1NUQVRFTUVOVF9OT05FEAES",
            "FQoRTE9HX1NUQVRFTUVOVF9EREwQAhIVChFMT0dfU1RBVEVNRU5UX01PRBAD",
            "EhUKEUxPR19TVEFURU1FTlRfQUxMEAQi5gEKFFRyYW5zYWN0aW9uSXNvbGF0",
            "aW9uEiUKIVRSQU5TQUNUSU9OX0lTT0xBVElPTl9VTlNQRUNJRklFRBAAEioK",
            "JlRSQU5TQUNUSU9OX0lTT0xBVElPTl9SRUFEX1VOQ09NTUlUVEVEEAESKAok",
            "VFJBTlNBQ1RJT05fSVNPTEFUSU9OX1JFQURfQ09NTUlUVEVEEAISKQolVFJB",
            "TlNBQ1RJT05fSVNPTEFUSU9OX1JFUEVBVEFCTEVfUkVBRBADEiYKIlRSQU5T",
            "QUNUSU9OX0lTT0xBVElPTl9TRVJJQUxJWkFCTEUQBEJzCiJ5YW5kZXguY2xv",
            "dWQuYXBpLm1kYi5wb3N0Z3Jlc3FsLnYxWk1naXRodWIuY29tL3lhbmRleC1j",
            "bG91ZC9nby1nZW5wcm90by95YW5kZXgvY2xvdWQvbWRiL3Bvc3RncmVzcWwv",
            "djE7cG9zdGdyZXNxbGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Yandex.Cloud.ValidationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.User), global::Yandex.Cloud.Mdb.Postgresql.V1.User.Parser, new[]{ "Name", "ClusterId", "Permissions", "ConnLimit", "Settings", "Login", "Grants" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.Permission), global::Yandex.Cloud.Mdb.Postgresql.V1.Permission.Parser, new[]{ "DatabaseName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.UserSpec), global::Yandex.Cloud.Mdb.Postgresql.V1.UserSpec.Parser, new[]{ "Name", "Password", "Permissions", "ConnLimit", "Settings", "Login", "Grants" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings), global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Parser, new[]{ "DefaultTransactionIsolation", "LockTimeout", "LogMinDurationStatement", "SynchronousCommit", "TempFileLimit", "LogStatement" }, null, new[]{ typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit), typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement), typeof(global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A PostgreSQL User resource. For more information, see
  /// the [Developer's Guide](/docs/managed-postgresql/concepts).
  /// </summary>
  internal sealed partial class User : pb::IMessage<User> {
    private static readonly pb::MessageParser<User> _parser = new pb::MessageParser<User>(() => new User());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<User> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Yandex.Cloud.Mdb.Postgresql.V1.UserReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public User() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public User(User other) : this() {
      name_ = other.name_;
      clusterId_ = other.clusterId_;
      permissions_ = other.permissions_.Clone();
      connLimit_ = other.connLimit_;
      settings_ = other.settings_ != null ? other.settings_.Clone() : null;
      Login = other.Login;
      grants_ = other.grants_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public User Clone() {
      return new User(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the PostgreSQL user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cluster_id" field.</summary>
    public const int ClusterIdFieldNumber = 2;
    private string clusterId_ = "";
    /// <summary>
    /// ID of the PostgreSQL cluster the user belongs to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClusterId {
      get { return clusterId_; }
      set {
        clusterId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(26, global::Yandex.Cloud.Mdb.Postgresql.V1.Permission.Parser);
    private readonly pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> permissions_ = new pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission>();
    /// <summary>
    /// Set of permissions granted to the user to access specific databases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "conn_limit" field.</summary>
    public const int ConnLimitFieldNumber = 4;
    private long connLimit_;
    /// <summary>
    /// Maximum number of database connections available to the user.
    ///
    /// When used in session pooling, this setting limits the number of connections to every single host in PostgreSQL cluster. In this case, the setting's value must be greater than the total number of connections that backend services can open to access the PostgreSQL cluster. The setting's value should not exceed the value of the [Cluster.config.postgresql_config_12.effective_config.max_connections] setting.
    ///
    /// When used in transaction pooling, this setting limits the number of user's active transactions; therefore, in this mode user can open thousands of connections, but only `N` concurrent connections will be opened, where `N` is the value of the setting.
    ///
    /// Minimum value: `10` (default: `50`), when used in session pooling.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ConnLimit {
      get { return connLimit_; }
      set {
        connLimit_ = value;
      }
    }

    /// <summary>Field number for the "settings" field.</summary>
    public const int SettingsFieldNumber = 5;
    private global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings settings_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings Settings {
      get { return settings_; }
      set {
        settings_ = value;
      }
    }

    /// <summary>Field number for the "login" field.</summary>
    public const int LoginFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_login_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? login_;
    /// <summary>
    /// This flag defines whether the user can login to a PostgreSQL database.
    ///
    /// Default value: `true` (login is allowed).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Login {
      get { return login_; }
      set {
        login_ = value;
      }
    }


    /// <summary>Field number for the "grants" field.</summary>
    public const int GrantsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_grants_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> grants_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Roles and privileges that are granted to the user (`GRANT &lt;role> TO &lt;user>`).
    ///
    /// For more information, see [the documentation](/docs/managed-postgresql/operations/grant).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Grants {
      get { return grants_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as User);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(User other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (ClusterId != other.ClusterId) return false;
      if(!permissions_.Equals(other.permissions_)) return false;
      if (ConnLimit != other.ConnLimit) return false;
      if (!object.Equals(Settings, other.Settings)) return false;
      if (Login != other.Login) return false;
      if(!grants_.Equals(other.grants_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (ClusterId.Length != 0) hash ^= ClusterId.GetHashCode();
      hash ^= permissions_.GetHashCode();
      if (ConnLimit != 0L) hash ^= ConnLimit.GetHashCode();
      if (settings_ != null) hash ^= Settings.GetHashCode();
      if (login_ != null) hash ^= Login.GetHashCode();
      hash ^= grants_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (ClusterId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ClusterId);
      }
      permissions_.WriteTo(output, _repeated_permissions_codec);
      if (ConnLimit != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ConnLimit);
      }
      if (settings_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Settings);
      }
      if (login_ != null) {
        _single_login_codec.WriteTagAndValue(output, Login);
      }
      grants_.WriteTo(output, _repeated_grants_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (ClusterId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterId);
      }
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      if (ConnLimit != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ConnLimit);
      }
      if (settings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Settings);
      }
      if (login_ != null) {
        size += _single_login_codec.CalculateSizeWithTag(Login);
      }
      size += grants_.CalculateSize(_repeated_grants_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(User other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.ClusterId.Length != 0) {
        ClusterId = other.ClusterId;
      }
      permissions_.Add(other.permissions_);
      if (other.ConnLimit != 0L) {
        ConnLimit = other.ConnLimit;
      }
      if (other.settings_ != null) {
        if (settings_ == null) {
          Settings = new global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings();
        }
        Settings.MergeFrom(other.Settings);
      }
      if (other.login_ != null) {
        if (login_ == null || other.Login != false) {
          Login = other.Login;
        }
      }
      grants_.Add(other.grants_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            ClusterId = input.ReadString();
            break;
          }
          case 26: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 32: {
            ConnLimit = input.ReadInt64();
            break;
          }
          case 42: {
            if (settings_ == null) {
              Settings = new global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings();
            }
            input.ReadMessage(Settings);
            break;
          }
          case 50: {
            bool? value = _single_login_codec.Read(input);
            if (login_ == null || value != false) {
              Login = value;
            }
            break;
          }
          case 58: {
            grants_.AddEntriesFrom(input, _repeated_grants_codec);
            break;
          }
        }
      }
    }

  }

  internal sealed partial class Permission : pb::IMessage<Permission> {
    private static readonly pb::MessageParser<Permission> _parser = new pb::MessageParser<Permission>(() => new Permission());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Permission> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Yandex.Cloud.Mdb.Postgresql.V1.UserReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission(Permission other) : this() {
      databaseName_ = other.databaseName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission Clone() {
      return new Permission(this);
    }

    /// <summary>Field number for the "database_name" field.</summary>
    public const int DatabaseNameFieldNumber = 1;
    private string databaseName_ = "";
    /// <summary>
    /// Name of the database that the permission grants access to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DatabaseName {
      get { return databaseName_; }
      set {
        databaseName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Permission);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Permission other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DatabaseName != other.DatabaseName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DatabaseName.Length != 0) hash ^= DatabaseName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DatabaseName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(DatabaseName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DatabaseName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DatabaseName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Permission other) {
      if (other == null) {
        return;
      }
      if (other.DatabaseName.Length != 0) {
        DatabaseName = other.DatabaseName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DatabaseName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  internal sealed partial class UserSpec : pb::IMessage<UserSpec> {
    private static readonly pb::MessageParser<UserSpec> _parser = new pb::MessageParser<UserSpec>(() => new UserSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UserSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Yandex.Cloud.Mdb.Postgresql.V1.UserReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSpec(UserSpec other) : this() {
      name_ = other.name_;
      password_ = other.password_;
      permissions_ = other.permissions_.Clone();
      ConnLimit = other.ConnLimit;
      settings_ = other.settings_ != null ? other.settings_.Clone() : null;
      Login = other.Login;
      grants_ = other.grants_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSpec Clone() {
      return new UserSpec(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Name of the PostgreSQL user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "password" field.</summary>
    public const int PasswordFieldNumber = 2;
    private string password_ = "";
    /// <summary>
    /// Password of the PostgreSQL user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Password {
      get { return password_; }
      set {
        password_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(26, global::Yandex.Cloud.Mdb.Postgresql.V1.Permission.Parser);
    private readonly pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> permissions_ = new pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission>();
    /// <summary>
    /// Set of permissions to grant to the user to access specific databases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Yandex.Cloud.Mdb.Postgresql.V1.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "conn_limit" field.</summary>
    public const int ConnLimitFieldNumber = 4;
    private static readonly pb::FieldCodec<long?> _single_connLimit_codec = pb::FieldCodec.ForStructWrapper<long>(34);
    private long? connLimit_;
    /// <summary>
    /// Maximum number of database connections that should be available to the user.
    ///
    /// When used in session pooling, this setting limits the number of connections to every single host in PostgreSQL cluster. In this case, the setting's value must be greater than the total number of connections that backend services can open to access the PostgreSQL cluster. The setting's value should not exceed the value of the [Cluster.config.postgresql_config_12.effective_config.max_connections] setting.
    ///
    /// When used in transaction pooling, this setting limits the number of user's active transactions; therefore, in this mode user can open thousands of connections, but only `N` concurrent connections will be opened, where `N` is the value of the setting.
    ///
    /// Minimum value: `10` (default: `50`), when used in session pooling.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long? ConnLimit {
      get { return connLimit_; }
      set {
        connLimit_ = value;
      }
    }


    /// <summary>Field number for the "settings" field.</summary>
    public const int SettingsFieldNumber = 5;
    private global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings settings_;
    /// <summary>
    /// PostgreSQL settings for the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings Settings {
      get { return settings_; }
      set {
        settings_ = value;
      }
    }

    /// <summary>Field number for the "login" field.</summary>
    public const int LoginFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_login_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? login_;
    /// <summary>
    /// This flag defines whether the user can login to a PostgreSQL database.
    ///
    /// Default value: `true` (login is allowed).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Login {
      get { return login_; }
      set {
        login_ = value;
      }
    }


    /// <summary>Field number for the "grants" field.</summary>
    public const int GrantsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_grants_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> grants_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Roles and privileges that are granted to the user (`GRANT &lt;role> TO &lt;user>`).
    ///
    /// For more information, see [the documentation](/docs/managed-postgresql/operations/grant).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Grants {
      get { return grants_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UserSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UserSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Password != other.Password) return false;
      if(!permissions_.Equals(other.permissions_)) return false;
      if (ConnLimit != other.ConnLimit) return false;
      if (!object.Equals(Settings, other.Settings)) return false;
      if (Login != other.Login) return false;
      if(!grants_.Equals(other.grants_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Password.Length != 0) hash ^= Password.GetHashCode();
      hash ^= permissions_.GetHashCode();
      if (connLimit_ != null) hash ^= ConnLimit.GetHashCode();
      if (settings_ != null) hash ^= Settings.GetHashCode();
      if (login_ != null) hash ^= Login.GetHashCode();
      hash ^= grants_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Password.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Password);
      }
      permissions_.WriteTo(output, _repeated_permissions_codec);
      if (connLimit_ != null) {
        _single_connLimit_codec.WriteTagAndValue(output, ConnLimit);
      }
      if (settings_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Settings);
      }
      if (login_ != null) {
        _single_login_codec.WriteTagAndValue(output, Login);
      }
      grants_.WriteTo(output, _repeated_grants_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Password.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Password);
      }
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      if (connLimit_ != null) {
        size += _single_connLimit_codec.CalculateSizeWithTag(ConnLimit);
      }
      if (settings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Settings);
      }
      if (login_ != null) {
        size += _single_login_codec.CalculateSizeWithTag(Login);
      }
      size += grants_.CalculateSize(_repeated_grants_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UserSpec other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Password.Length != 0) {
        Password = other.Password;
      }
      permissions_.Add(other.permissions_);
      if (other.connLimit_ != null) {
        if (connLimit_ == null || other.ConnLimit != 0L) {
          ConnLimit = other.ConnLimit;
        }
      }
      if (other.settings_ != null) {
        if (settings_ == null) {
          Settings = new global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings();
        }
        Settings.MergeFrom(other.Settings);
      }
      if (other.login_ != null) {
        if (login_ == null || other.Login != false) {
          Login = other.Login;
        }
      }
      grants_.Add(other.grants_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Password = input.ReadString();
            break;
          }
          case 26: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 34: {
            long? value = _single_connLimit_codec.Read(input);
            if (connLimit_ == null || value != 0L) {
              ConnLimit = value;
            }
            break;
          }
          case 42: {
            if (settings_ == null) {
              Settings = new global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings();
            }
            input.ReadMessage(Settings);
            break;
          }
          case 50: {
            bool? value = _single_login_codec.Read(input);
            if (login_ == null || value != false) {
              Login = value;
            }
            break;
          }
          case 58: {
            grants_.AddEntriesFrom(input, _repeated_grants_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// PostgreSQL user settings.
  /// </summary>
  internal sealed partial class UserSettings : pb::IMessage<UserSettings> {
    private static readonly pb::MessageParser<UserSettings> _parser = new pb::MessageParser<UserSettings>(() => new UserSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UserSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Yandex.Cloud.Mdb.Postgresql.V1.UserReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSettings(UserSettings other) : this() {
      defaultTransactionIsolation_ = other.defaultTransactionIsolation_;
      LockTimeout = other.LockTimeout;
      LogMinDurationStatement = other.LogMinDurationStatement;
      synchronousCommit_ = other.synchronousCommit_;
      TempFileLimit = other.TempFileLimit;
      logStatement_ = other.logStatement_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UserSettings Clone() {
      return new UserSettings(this);
    }

    /// <summary>Field number for the "default_transaction_isolation" field.</summary>
    public const int DefaultTransactionIsolationFieldNumber = 1;
    private global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation defaultTransactionIsolation_ = global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation.Unspecified;
    /// <summary>
    /// SQL sets an isolation level for each transaction.
    /// This setting defines the default isolation level to be set for all new SQL transactions.
    ///
    /// See in-depth description in [PostgreSQL documentation](https://www.postgresql.org/docs/current/transaction-iso.html).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation DefaultTransactionIsolation {
      get { return defaultTransactionIsolation_; }
      set {
        defaultTransactionIsolation_ = value;
      }
    }

    /// <summary>Field number for the "lock_timeout" field.</summary>
    public const int LockTimeoutFieldNumber = 2;
    private static readonly pb::FieldCodec<long?> _single_lockTimeout_codec = pb::FieldCodec.ForStructWrapper<long>(18);
    private long? lockTimeout_;
    /// <summary>
    /// The maximum time (in milliseconds) for any statement to wait for acquiring a lock on an table, index, row or other database object.
    /// If the wait time is longer than the specified amount, then this statement is aborted.
    ///
    /// Default value: `0` (no control is enforced, a statement waiting time is unlimited).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long? LockTimeout {
      get { return lockTimeout_; }
      set {
        lockTimeout_ = value;
      }
    }


    /// <summary>Field number for the "log_min_duration_statement" field.</summary>
    public const int LogMinDurationStatementFieldNumber = 3;
    private static readonly pb::FieldCodec<long?> _single_logMinDurationStatement_codec = pb::FieldCodec.ForStructWrapper<long>(26);
    private long? logMinDurationStatement_;
    /// <summary>
    /// This setting controls logging of the duration of statements.
    ///
    /// The duration of each completed statement will be logged if the statement ran for at least the specified amount of time (in milliseconds).
    /// E.g., if this setting's value is set to `500`, a statement that took 300 milliseconds to complete will not be logged; on the other hand, the one that took 2000 milliseconds to complete, will be logged.
    ///
    /// Value of `0` forces PostgreSQL to log the duration of all statements.
    ///
    /// Value of `-1` (default) disables logging of the duration of statements.
    ///
    /// See in-depth description in [PostgreSQL documentation](https://www.postgresql.org/docs/current/runtime-config-logging.html).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long? LogMinDurationStatement {
      get { return logMinDurationStatement_; }
      set {
        logMinDurationStatement_ = value;
      }
    }


    /// <summary>Field number for the "synchronous_commit" field.</summary>
    public const int SynchronousCommitFieldNumber = 4;
    private global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit synchronousCommit_ = global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit.Unspecified;
    /// <summary>
    /// This setting defines whether DBMS will commit transaction in a synchronous way.
    ///
    /// When synchronization is enabled, cluster waits for the synchronous operations to be completed prior to reporting `success` to the client.
    /// These operations guarantee different levels of the data safety and visibility in the cluster.
    ///
    /// See in-depth description in [PostgreSQL documentation](https://www.postgresql.org/docs/current/runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit SynchronousCommit {
      get { return synchronousCommit_; }
      set {
        synchronousCommit_ = value;
      }
    }

    /// <summary>Field number for the "temp_file_limit" field.</summary>
    public const int TempFileLimitFieldNumber = 5;
    private static readonly pb::FieldCodec<long?> _single_tempFileLimit_codec = pb::FieldCodec.ForStructWrapper<long>(42);
    private long? tempFileLimit_;
    /// <summary>
    /// The maximum storage space size (in kilobytes) that a single process can use to create temporary files.
    /// If a transaction exceeds this limit during execution, it will be aborted.
    ///
    /// A huge query may not fit into a server's RAM, therefore PostgreSQL will use some storage to store and execute such a query. Too big queries can make excessive use of the storage system, effectively making other quieries to run slow. This setting prevents execution of a big queries that can influence other queries by limiting size of temporary files.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long? TempFileLimit {
      get { return tempFileLimit_; }
      set {
        tempFileLimit_ = value;
      }
    }


    /// <summary>Field number for the "log_statement" field.</summary>
    public const int LogStatementFieldNumber = 6;
    private global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement logStatement_ = global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement.Unspecified;
    /// <summary>
    /// This setting specifies which SQL statements should be logged (on the user level).
    ///
    /// See in-depth description in [PostgreSQL documentation](https://www.postgresql.org/docs/current/runtime-config-logging.html).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement LogStatement {
      get { return logStatement_; }
      set {
        logStatement_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UserSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UserSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DefaultTransactionIsolation != other.DefaultTransactionIsolation) return false;
      if (LockTimeout != other.LockTimeout) return false;
      if (LogMinDurationStatement != other.LogMinDurationStatement) return false;
      if (SynchronousCommit != other.SynchronousCommit) return false;
      if (TempFileLimit != other.TempFileLimit) return false;
      if (LogStatement != other.LogStatement) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DefaultTransactionIsolation != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation.Unspecified) hash ^= DefaultTransactionIsolation.GetHashCode();
      if (lockTimeout_ != null) hash ^= LockTimeout.GetHashCode();
      if (logMinDurationStatement_ != null) hash ^= LogMinDurationStatement.GetHashCode();
      if (SynchronousCommit != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit.Unspecified) hash ^= SynchronousCommit.GetHashCode();
      if (tempFileLimit_ != null) hash ^= TempFileLimit.GetHashCode();
      if (LogStatement != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement.Unspecified) hash ^= LogStatement.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DefaultTransactionIsolation != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation.Unspecified) {
        output.WriteRawTag(8);
        output.WriteEnum((int) DefaultTransactionIsolation);
      }
      if (lockTimeout_ != null) {
        _single_lockTimeout_codec.WriteTagAndValue(output, LockTimeout);
      }
      if (logMinDurationStatement_ != null) {
        _single_logMinDurationStatement_codec.WriteTagAndValue(output, LogMinDurationStatement);
      }
      if (SynchronousCommit != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit.Unspecified) {
        output.WriteRawTag(32);
        output.WriteEnum((int) SynchronousCommit);
      }
      if (tempFileLimit_ != null) {
        _single_tempFileLimit_codec.WriteTagAndValue(output, TempFileLimit);
      }
      if (LogStatement != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LogStatement);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DefaultTransactionIsolation != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DefaultTransactionIsolation);
      }
      if (lockTimeout_ != null) {
        size += _single_lockTimeout_codec.CalculateSizeWithTag(LockTimeout);
      }
      if (logMinDurationStatement_ != null) {
        size += _single_logMinDurationStatement_codec.CalculateSizeWithTag(LogMinDurationStatement);
      }
      if (SynchronousCommit != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SynchronousCommit);
      }
      if (tempFileLimit_ != null) {
        size += _single_tempFileLimit_codec.CalculateSizeWithTag(TempFileLimit);
      }
      if (LogStatement != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LogStatement);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UserSettings other) {
      if (other == null) {
        return;
      }
      if (other.DefaultTransactionIsolation != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation.Unspecified) {
        DefaultTransactionIsolation = other.DefaultTransactionIsolation;
      }
      if (other.lockTimeout_ != null) {
        if (lockTimeout_ == null || other.LockTimeout != 0L) {
          LockTimeout = other.LockTimeout;
        }
      }
      if (other.logMinDurationStatement_ != null) {
        if (logMinDurationStatement_ == null || other.LogMinDurationStatement != 0L) {
          LogMinDurationStatement = other.LogMinDurationStatement;
        }
      }
      if (other.SynchronousCommit != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit.Unspecified) {
        SynchronousCommit = other.SynchronousCommit;
      }
      if (other.tempFileLimit_ != null) {
        if (tempFileLimit_ == null || other.TempFileLimit != 0L) {
          TempFileLimit = other.TempFileLimit;
        }
      }
      if (other.LogStatement != global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement.Unspecified) {
        LogStatement = other.LogStatement;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DefaultTransactionIsolation = (global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.TransactionIsolation) input.ReadEnum();
            break;
          }
          case 18: {
            long? value = _single_lockTimeout_codec.Read(input);
            if (lockTimeout_ == null || value != 0L) {
              LockTimeout = value;
            }
            break;
          }
          case 26: {
            long? value = _single_logMinDurationStatement_codec.Read(input);
            if (logMinDurationStatement_ == null || value != 0L) {
              LogMinDurationStatement = value;
            }
            break;
          }
          case 32: {
            SynchronousCommit = (global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.SynchronousCommit) input.ReadEnum();
            break;
          }
          case 42: {
            long? value = _single_tempFileLimit_codec.Read(input);
            if (tempFileLimit_ == null || value != 0L) {
              TempFileLimit = value;
            }
            break;
          }
          case 48: {
            LogStatement = (global::Yandex.Cloud.Mdb.Postgresql.V1.UserSettings.Types.LogStatement) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the UserSettings message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      internal enum SynchronousCommit {
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// (default value) success is reported to the client if the data is in WAL (Write-Ahead Log), and WAL is written to the storage of both the master and its synchronous standby server.
        /// </summary>
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_ON")] On = 1,
        /// <summary>
        /// success is reported to the client even if the data is not in WAL.
        /// There is no synchronous write operation, data may be loss in case of storage subsystem failure.
        /// </summary>
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_OFF")] Off = 2,
        /// <summary>
        /// success is reported to the client if the data is in WAL, and WAL is written to the storage of the master server.
        /// The transaction may be lost due to storage subsystem failure on the master server.
        /// </summary>
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_LOCAL")] Local = 3,
        /// <summary>
        /// success is reported to the client if the data is in WAL, WAL is written to the storage of the master server, and the server's synchronous standby indicates that it has received WAL and written it out to its operating system.
        /// The transaction may be lost due to simultaneous storage subsystem failure on the master and operating system's failure on the synchronous standby.
        /// </summary>
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_REMOTE_WRITE")] RemoteWrite = 4,
        /// <summary>
        /// success is reported to the client if the data is in WAL (Write-Ahead Log), WAL is written to the storage of the master server, and its synchronous standby indicates that it has received WAL and applied it.
        /// The transaction may be lost due to irrecoverably failure of both the master and its synchronous standby.
        /// </summary>
        [pbr::OriginalName("SYNCHRONOUS_COMMIT_REMOTE_APPLY")] RemoteApply = 5,
      }

      internal enum LogStatement {
        [pbr::OriginalName("LOG_STATEMENT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// (default) logs none of SQL statements.
        /// </summary>
        [pbr::OriginalName("LOG_STATEMENT_NONE")] None = 1,
        /// <summary>
        /// logs all data definition statements (such as `CREATE`, `ALTER`, `DROP` and others).
        /// </summary>
        [pbr::OriginalName("LOG_STATEMENT_DDL")] Ddl = 2,
        /// <summary>
        /// logs all statements that fall in the `LOG_STATEMENT_DDL` category plus data-modifying statements (such as `INSERT`, `UPDATE` and others).
        /// </summary>
        [pbr::OriginalName("LOG_STATEMENT_MOD")] Mod = 3,
        /// <summary>
        /// logs all SQL statements.
        /// </summary>
        [pbr::OriginalName("LOG_STATEMENT_ALL")] All = 4,
      }

      internal enum TransactionIsolation {
        [pbr::OriginalName("TRANSACTION_ISOLATION_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// this level behaves like `TRANSACTION_ISOLATION_READ_COMMITTED` in PostgreSQL.
        /// </summary>
        [pbr::OriginalName("TRANSACTION_ISOLATION_READ_UNCOMMITTED")] ReadUncommitted = 1,
        /// <summary>
        /// (default) on this level query sees only data committed before the query began.
        /// </summary>
        [pbr::OriginalName("TRANSACTION_ISOLATION_READ_COMMITTED")] ReadCommitted = 2,
        /// <summary>
        /// on this level all subsequent queries in a transaction will see the same rows, that were read by the first `SELECT` or `INSERT` query in this transaction, unchanged (these rows are locked during the first query).
        /// </summary>
        [pbr::OriginalName("TRANSACTION_ISOLATION_REPEATABLE_READ")] RepeatableRead = 3,
        /// <summary>
        /// this level provides the strictest transaction isolation.
        /// All queries in the current transaction see only the rows that were fixed prior to execution of the first `SELECT` or `INSERT` query in this transaction.
        /// If read and write operations in a concurrent set of serializable transactions overlap and this may cause an inconsistency that is not possible during the serial transaction execution, then one of the transaction will be rolled back, triggering a serialization failure.
        /// </summary>
        [pbr::OriginalName("TRANSACTION_ISOLATION_SERIALIZABLE")] Serializable = 4,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
